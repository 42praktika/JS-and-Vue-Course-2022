{"version":3,"file":"core.bundle.js","mappings":";;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://Project1/./js/catfacts.js","webpack://Project1/./js/const.js","webpack://Project1/./js/currency.js","webpack://Project1/./js/helpers/melanke-watchjs.js","webpack://Project1/./js/holidays.js","webpack://Project1/./js/state.js","webpack://Project1/./js/watchers.js","webpack://Project1/webpack/bootstrap","webpack://Project1/webpack/runtime/define property getters","webpack://Project1/webpack/runtime/hasOwnProperty shorthand","webpack://Project1/webpack/runtime/make namespace object","webpack://Project1/./js/index.js"],"sourcesContent":["import { factState } from \"./state.js\";\nexport const catfacts = () => {\n  const modal = document.querySelector('.modal-content');\n  const list = document.createElement('div');\n  list.classList = 'facts-list';\n  modal.append(list);\n  const button = document.createElement('button');\n  button.classList = 'btn';\n  button.textContent = 'Get fact!';\n  modal.append(button);\n  button.addEventListener('click', () => {\n    fetch('https://meowfacts.herokuapp.com/?lang=rus').then(response => response.json()).then(facts => factState.facts = factState.facts.concat(facts)).catch(err => console.error(err));\n    factList(factState.facts);\n  });\n};\n\nconst createFact = fact => '<div class=\"fact\"><p>' + fact.data + '</p></div>';\n\nconst factList = facts => {\n  const list = document.querySelector('.facts-list');\n  list.innerHTML = ' ';\n\n  if (facts.length) {\n    facts.forEach(fact => list.innerHTML = createFact(fact));\n  }\n};","export const MODALS_TYPES = {\n  NONE: 'none',\n  FIRST: 'CatFacts',\n  SECOND: 'Holidays',\n  THIRD: 'Currency'\n};\nexport const BUTTONS = [{\n  text: 'Facts about cats',\n  type: MODALS_TYPES.FIRST\n}, {\n  text: 'Holidays',\n  type: MODALS_TYPES.SECOND\n}, {\n  text: 'Exchange rate',\n  type: MODALS_TYPES.THIRD\n}];\nexport const MODALS = [{\n  text: 'Interesting facts about cats',\n  type: MODALS_TYPES.FIRST\n}, {\n  text: 'Information about holidays',\n  type: MODALS_TYPES.SECOND\n}, {\n  text: 'Exchange rate on the selected date',\n  type: MODALS_TYPES.THIRD\n}];","export const currency = () => {\n  const content = document.querySelectorAll('.modal-content');\n  const currencyAll = document.createElement('div');\n  currencyAll.classList = 'currency-data';\n  content[2].append(currencyAll);\n  const dateSelect = document.createElement('input');\n  dateSelect.type = 'date';\n  dateSelect.classList = 'date';\n  currencyAll.append(dateSelect);\n\n  const getTodayDate = () => {\n    let today = new Date();\n    let dd = String(today.getDate()).padStart(2, '0');\n    let mm = String(today.getMonth() + 1).padStart(2, '0');\n    let yyyy = today.getFullYear();\n    return yyyy + '-' + mm + '-' + dd;\n  };\n\n  dateSelect.max = getTodayDate();\n  const table = document.createElement('table');\n  table.classList = 'table';\n  dateSelect.addEventListener('input', () => {\n    let dataSelected = dateSelect.value;\n    const table = document.createElement('table');\n    table.classList = 'table';\n    fetch('https://api.currencyscoop.com/v1/historical?date=' + dataSelected + '?&base=RUB&api_key=22bc0fa553204ae1886329841e130441').then(response => response.json()).then(currency => {\n      let obj = Object.entries(currency.response.rates);\n\n      for (let i = 0; i < obj.length; i++) {\n        const cell = document.createElement('th');\n        cell.classList = 'cell2';\n        const line = document.createElement('tr');\n        line.classList = 'line';\n        cell.textContent = 'Currency name , rate : ' + Object.values(obj[i]);\n        line.append(cell);\n        table.append(line);\n        currencyAll.append(table);\n      }\n    }).catch(err => console.error(err));\n    const th = document.querySelectorAll('.cell2');\n    th.forEach(t => {\n      t.remove();\n    });\n  });\n};","var WatchJS = {\n  noMore: false,\n  // use WatchJS.suspend(obj) instead\n  useDirtyCheck: false,\n  // use only dirty checking to track changes.\n  preserveExistingSetters: false\n},\n    lengthsubjects = [];\nvar dirtyChecklist = [];\nvar pendingChanges = []; // used coalesce changes from defineProperty and __defineSetter__\n\nvar supportDefineProperty = false;\n\ntry {\n  supportDefineProperty = Object.defineProperty && Object.defineProperty({}, 'x', {});\n} catch (ex) {\n  /* not supported */\n}\n\nvar isFunction = function (functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) == '[object Function]';\n};\n\nvar isInt = function (x) {\n  return x % 1 === 0;\n};\n\nvar isArray = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nvar isObject = function (obj) {\n  return {}.toString.apply(obj) === '[object Object]';\n};\n\nvar getObjDiff = function (a, b) {\n  var aplus = [],\n      bplus = [];\n\n  if (!(typeof a == \"string\") && !(typeof b == \"string\")) {\n    if (isArray(a) && b) {\n      for (var i = 0; i < a.length; i++) {\n        if (b[i] === undefined) aplus.push(i);\n      }\n    } else {\n      for (var i in a) {\n        if (a.hasOwnProperty(i)) {\n          if (b && !b.hasOwnProperty(i)) {\n            aplus.push(i);\n          }\n        }\n      }\n    }\n\n    if (isArray(b) && a) {\n      for (var j = 0; j < b.length; j++) {\n        if (a[j] === undefined) bplus.push(j);\n      }\n    } else {\n      for (var j in b) {\n        if (b.hasOwnProperty(j)) {\n          if (a && !a.hasOwnProperty(j)) {\n            bplus.push(j);\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    added: aplus,\n    removed: bplus\n  };\n};\n\nvar clone = function (obj) {\n  if (null == obj || \"object\" != typeof obj) {\n    return obj;\n  }\n\n  var copy = obj.constructor();\n\n  for (var attr in obj) {\n    copy[attr] = obj[attr];\n  }\n\n  return copy;\n};\n\nvar getExistingSetter = function (obj, propName) {\n  if (WatchJS.preserveExistingSetters) {\n    var existing = Object.getOwnPropertyDescriptor(obj, propName);\n    return existing.set;\n  }\n\n  return undefined;\n};\n\nvar defineGetAndSet = function (obj, propName, getter, setter) {\n  try {\n    var existingSetter = getExistingSetter(obj, propName);\n    Object.defineProperty(obj, propName, {\n      get: getter,\n      set: function (value) {\n        setter.call(this, value, true); // coalesce changes\n\n        if (existingSetter) {\n          existingSetter(value);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    });\n  } catch (e1) {\n    try {\n      Object.prototype.__defineGetter__.call(obj, propName, getter);\n\n      Object.prototype.__defineSetter__.call(obj, propName, function (value) {\n        setter.call(this, value, true); // coalesce changes\n      });\n    } catch (e2) {\n      observeDirtyChanges(obj, propName, setter); //throw new Error(\"watchJS error: browser not supported :/\")\n    }\n  }\n};\n\nvar defineProp = function (obj, propName, value) {\n  try {\n    Object.defineProperty(obj, propName, {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: value\n    });\n  } catch (error) {\n    obj[propName] = value;\n  }\n};\n\nvar observeDirtyChanges = function (obj, propName, setter) {\n  dirtyChecklist[dirtyChecklist.length] = {\n    prop: propName,\n    object: obj,\n    orig: clone(obj[propName]),\n    callback: setter\n  };\n};\n\nvar watch = function () {\n  if (isFunction(arguments[1])) {\n    watchAll.apply(this, arguments);\n  } else if (isArray(arguments[1])) {\n    watchMany.apply(this, arguments);\n  } else {\n    watchOne.apply(this, arguments);\n  }\n};\n\nvar watchAll = function (obj, watcher, level, addNRemove) {\n  if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n    //accepts only objects and array (not string)\n    return;\n  }\n\n  if (isArray(obj)) {\n    defineWatcher(obj, \"__watchall__\", watcher, level); // watch all changes on the array\n\n    if (level === undefined || level > 0) {\n      for (var prop = 0; prop < obj.length; prop++) {\n        // watch objects in array\n        watchAll(obj[prop], watcher, level, addNRemove);\n      }\n    }\n  } else {\n    var prop,\n        props = [];\n\n    for (prop in obj) {\n      //for each attribute if obj is an object\n      if (prop == \"$val\" || !supportDefineProperty && prop === 'watchers') {\n        continue;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n        props.push(prop); //put in the props\n      }\n    }\n\n    watchMany(obj, props, watcher, level, addNRemove); //watch all items of the props\n  }\n\n  if (addNRemove) {\n    pushToLengthSubjects(obj, \"$$watchlengthsubjectroot\", watcher, level);\n  }\n};\n\nvar watchMany = function (obj, props, watcher, level, addNRemove) {\n  if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n    //accepts only objects and array (not string)\n    return;\n  }\n\n  for (var i = 0; i < props.length; i++) {\n    //watch each property\n    var prop = props[i];\n    watchOne(obj, prop, watcher, level, addNRemove);\n  }\n};\n\nvar watchOne = function (obj, prop, watcher, level, addNRemove) {\n  if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n    //accepts only objects and array (not string)\n    return;\n  }\n\n  if (isFunction(obj[prop])) {\n    //dont watch if it is a function\n    return;\n  }\n\n  if (obj[prop] != null && (level === undefined || level > 0)) {\n    watchAll(obj[prop], watcher, level !== undefined ? level - 1 : level); //recursively\n    // watch all\n    // attributes of\n    // this\n  }\n\n  defineWatcher(obj, prop, watcher, level);\n\n  if (addNRemove && (level === undefined || level > 0)) {\n    pushToLengthSubjects(obj, prop, watcher, level);\n  }\n};\n\nvar unwatch = function () {\n  if (isFunction(arguments[1])) {\n    unwatchAll.apply(this, arguments);\n  } else if (isArray(arguments[1])) {\n    unwatchMany.apply(this, arguments);\n  } else {\n    unwatchOne.apply(this, arguments);\n  }\n};\n\nvar unwatchAll = function (obj, watcher) {\n  if (obj instanceof String || !(obj instanceof Object) && !isArray(obj)) {\n    //accepts only objects and array (not string)\n    return;\n  }\n\n  if (isArray(obj)) {\n    var props = ['__watchall__'];\n\n    for (var prop = 0; prop < obj.length; prop++) {\n      //for each item if obj is an array\n      props.push(prop); //put in the props\n    }\n\n    unwatchMany(obj, props, watcher); //watch all itens of the props\n  } else {\n    var unwatchPropsInObject = function (obj2) {\n      var props = [];\n\n      for (var prop2 in obj2) {\n        //for each attribute if obj is an object\n        if (obj2.hasOwnProperty(prop2)) {\n          if (obj2[prop2] instanceof Object) {\n            unwatchPropsInObject(obj2[prop2]); //recurs into object props\n          } else {\n            props.push(prop2); //put in the props\n          }\n        }\n      }\n\n      unwatchMany(obj2, props, watcher); //unwatch all of the props\n    };\n\n    unwatchPropsInObject(obj);\n  }\n};\n\nvar unwatchMany = function (obj, props, watcher) {\n  for (var prop2 in props) {\n    //watch each attribute of \"props\" if is an object\n    if (props.hasOwnProperty(prop2)) {\n      unwatchOne(obj, props[prop2], watcher);\n    }\n  }\n};\n\nvar timeouts = [],\n    timerID = null;\n\nfunction clearTimerID() {\n  timerID = null;\n\n  for (var i = 0; i < timeouts.length; i++) {\n    timeouts[i]();\n  }\n\n  timeouts.length = 0;\n}\n\nvar getTimerID = function () {\n  if (!timerID) {\n    timerID = setTimeout(clearTimerID);\n  }\n\n  return timerID;\n};\n\nvar registerTimeout = function (fn) {\n  // register function to be called on timeout\n  if (timerID == null) getTimerID();\n  timeouts[timeouts.length] = fn;\n}; // Track changes made to an array, object or an object's property\n// and invoke callback with a single change object containing type, value, oldvalue and array\n// splices Syntax:  trackChange(obj, callback, recursive, addNRemove) trackChange(obj, prop,\n// callback, recursive, addNRemove)\n\n\nvar trackChange = function () {\n  var fn = isFunction(arguments[2]) ? trackProperty : trackObject;\n  fn.apply(this, arguments);\n}; // track changes made to an object and invoke callback with a single change object containing\n// type, value and array splices\n\n\nvar trackObject = function (obj, callback, recursive, addNRemove) {\n  var change = null,\n      lastTimerID = -1;\n  var isArr = isArray(obj);\n\n  var level,\n      fn = function (prop, action, newValue, oldValue) {\n    var timerID = getTimerID();\n\n    if (lastTimerID !== timerID) {\n      // check if timer has changed since last update\n      lastTimerID = timerID;\n      change = {\n        type: 'update'\n      };\n      change['value'] = obj;\n      change['splices'] = null;\n      registerTimeout(function () {\n        callback.call(this, change);\n        change = null;\n      });\n    } // create splices for array changes\n\n\n    if (isArr && obj === this && change !== null) {\n      if (action === 'pop' || action === 'shift') {\n        newValue = [];\n        oldValue = [oldValue];\n      } else if (action === 'push' || action === 'unshift') {\n        newValue = [newValue];\n        oldValue = [];\n      } else if (action !== 'splice') {\n        return; // return here - for reverse and sort operations we don't need to\n        // return splices. a simple update will do\n      }\n\n      if (!change.splices) change.splices = [];\n      change.splices[change.splices.length] = {\n        index: prop,\n        deleteCount: oldValue ? oldValue.length : 0,\n        addedCount: newValue ? newValue.length : 0,\n        added: newValue,\n        deleted: oldValue\n      };\n    }\n  };\n\n  level = recursive == true ? undefined : 0;\n  watchAll(obj, fn, level, addNRemove);\n}; // track changes made to the property of an object and invoke callback with a single change\n// object containing type, value, oldvalue and splices\n\n\nvar trackProperty = function (obj, prop, callback, recursive, addNRemove) {\n  if (obj && prop) {\n    watchOne(obj, prop, function (prop, action, newvalue, oldvalue) {\n      var change = {\n        type: 'update'\n      };\n      change['value'] = newvalue;\n      change['oldvalue'] = oldvalue;\n\n      if (recursive && isObject(newvalue) || isArray(newvalue)) {\n        trackObject(newvalue, callback, recursive, addNRemove);\n      }\n\n      callback.call(this, change);\n    }, 0);\n\n    if (recursive && isObject(obj[prop]) || isArray(obj[prop])) {\n      trackObject(obj[prop], callback, recursive, addNRemove);\n    }\n  }\n};\n\nvar defineWatcher = function (obj, prop, watcher, level) {\n  var newWatcher = false;\n  var isArr = isArray(obj);\n\n  if (!obj.watchers) {\n    defineProp(obj, \"watchers\", {});\n\n    if (isArr) {\n      // watch array functions\n      watchFunctions(obj, function (index, action, newValue, oldValue) {\n        addPendingChange(obj, index, action, newValue, oldValue);\n\n        if (level !== 0 && newValue && (isObject(newValue) || isArray(newValue))) {\n          var i,\n              n,\n              ln,\n              wAll,\n              watchList = obj.watchers[prop];\n\n          if (wAll = obj.watchers['__watchall__']) {\n            watchList = watchList ? watchList.concat(wAll) : wAll;\n          }\n\n          ln = watchList ? watchList.length : 0;\n\n          for (i = 0; i < ln; i++) {\n            if (action !== 'splice') {\n              watchAll(newValue, watchList[i], level === undefined ? level : level - 1);\n            } else {\n              // watch spliced values\n              for (n = 0; n < newValue.length; n++) {\n                watchAll(newValue[n], watchList[i], level === undefined ? level : level - 1);\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n\n  if (!obj.watchers[prop]) {\n    obj.watchers[prop] = [];\n    if (!isArr) newWatcher = true;\n  }\n\n  for (var i = 0; i < obj.watchers[prop].length; i++) {\n    if (obj.watchers[prop][i] === watcher) {\n      return;\n    }\n  }\n\n  obj.watchers[prop].push(watcher); //add the new watcher to the watchers array\n\n  if (newWatcher) {\n    var val = obj[prop];\n\n    var getter = function () {\n      return val;\n    };\n\n    var setter = function (newval, delayWatcher) {\n      var oldval = val;\n      val = newval;\n\n      if (level !== 0 && obj[prop] && (isObject(obj[prop]) || isArray(obj[prop])) && !obj[prop].watchers) {\n        // watch sub properties\n        var i,\n            ln = obj.watchers[prop].length;\n\n        for (i = 0; i < ln; i++) {\n          watchAll(obj[prop], obj.watchers[prop][i], level === undefined ? level : level - 1);\n        }\n      } //watchFunctions(obj, prop);\n\n\n      if (isSuspended(obj, prop)) {\n        resume(obj, prop);\n        return;\n      }\n\n      if (!WatchJS.noMore) {\n        // this does not work with Object.observe\n        //if (JSON.stringify(oldval) !== JSON.stringify(newval)) {\n        if (obj[prop] instanceof Date && oldval && newval) {\n          oldval = oldval.valueOf();\n          newval = newval.valueOf();\n        }\n\n        if (oldval !== newval) {\n          if (!delayWatcher) {\n            callWatchers(obj, prop, \"set\", newval, oldval);\n          } else {\n            addPendingChange(obj, prop, \"set\", newval, oldval);\n          }\n\n          WatchJS.noMore = false;\n        }\n      }\n    };\n\n    if (WatchJS.useDirtyCheck) {\n      observeDirtyChanges(obj, prop, setter);\n    } else {\n      defineGetAndSet(obj, prop, getter, setter);\n    }\n  }\n};\n\nvar callWatchers = function (obj, prop, action, newval, oldval) {\n  if (prop !== undefined) {\n    var ln,\n        wl,\n        watchList = obj.watchers[prop];\n\n    if (wl = obj.watchers['__watchall__']) {\n      watchList = watchList ? watchList.concat(wl) : wl;\n    }\n\n    ln = watchList ? watchList.length : 0;\n\n    for (var wr = 0; wr < ln; wr++) {\n      watchList[wr].call(obj, prop, action, newval, oldval);\n    }\n  } else {\n    for (var prop in obj) {\n      //call all\n      if (obj.hasOwnProperty(prop)) {\n        callWatchers(obj, prop, action, newval, oldval);\n      }\n    }\n  }\n};\n\nvar methodNames = ['pop', 'push', 'reverse', 'shift', 'sort', 'slice', 'unshift', 'splice'];\n\nvar defineArrayMethodWatcher = function (obj, original, methodName, callback) {\n  defineProp(obj, methodName, function () {\n    var index = 0;\n    var i, newValue, oldValue, response; // get values before splicing array\n\n    if (methodName === 'splice') {\n      var start = arguments[0];\n      var end = start + arguments[1];\n      oldValue = obj.slice(start, end);\n      newValue = [];\n\n      for (i = 2; i < arguments.length; i++) {\n        newValue[i - 2] = arguments[i];\n      }\n\n      index = start;\n    } else {\n      newValue = arguments.length > 0 ? arguments[0] : undefined;\n    }\n\n    response = original.apply(obj, arguments);\n\n    if (methodName !== 'slice') {\n      if (methodName === 'pop') {\n        oldValue = response;\n        index = obj.length;\n      } else if (methodName === 'push') {\n        index = obj.length - 1;\n      } else if (methodName === 'shift') {\n        oldValue = response;\n      } else if (methodName !== 'unshift' && newValue === undefined) {\n        newValue = response;\n      }\n\n      callback.call(obj, index, methodName, newValue, oldValue);\n    }\n\n    return response;\n  });\n};\n\nvar watchFunctions = function (obj, callback) {\n  if (!isFunction(callback) || !obj || obj instanceof String || !isArray(obj)) {\n    return;\n  }\n\n  for (var i = methodNames.length, methodName; i--;) {\n    methodName = methodNames[i];\n    defineArrayMethodWatcher(obj, obj[methodName], methodName, callback);\n  }\n};\n\nvar unwatchOne = function (obj, prop, watcher) {\n  if (prop) {\n    if (obj.watchers && obj.watchers[prop]) {\n      if (watcher === undefined) {\n        delete obj.watchers[prop]; // remove all property watchers\n      } else {\n        for (var i = 0; i < obj.watchers[prop].length; i++) {\n          var w = obj.watchers[prop][i];\n\n          if (w == watcher) {\n            obj.watchers[prop].splice(i, 1);\n          }\n        }\n      }\n    }\n  } else {\n    delete obj.watchers;\n  }\n\n  removeFromLengthSubjects(obj, prop, watcher);\n  removeFromDirtyChecklist(obj, prop);\n}; // suspend watchers until next update cycle\n\n\nvar suspend = function (obj, prop) {\n  if (obj.watchers) {\n    var name = '__wjs_suspend__' + (prop !== undefined ? prop : '');\n    obj.watchers[name] = true;\n  }\n};\n\nvar isSuspended = function (obj, prop) {\n  return obj.watchers && (obj.watchers['__wjs_suspend__'] || obj.watchers['__wjs_suspend__' + prop]);\n}; // resumes preivously suspended watchers\n\n\nvar resume = function (obj, prop) {\n  registerTimeout(function () {\n    delete obj.watchers['__wjs_suspend__'];\n    delete obj.watchers['__wjs_suspend__' + prop];\n  });\n};\n\nvar pendingTimerID = null;\n\nvar addPendingChange = function (obj, prop, mode, newval, oldval) {\n  pendingChanges[pendingChanges.length] = {\n    obj: obj,\n    prop: prop,\n    mode: mode,\n    newval: newval,\n    oldval: oldval\n  };\n\n  if (pendingTimerID === null) {\n    pendingTimerID = setTimeout(applyPendingChanges);\n  }\n};\n\nvar applyPendingChanges = function () {\n  // apply pending changes\n  var change = null;\n  pendingTimerID = null;\n\n  for (var i = 0; i < pendingChanges.length; i++) {\n    change = pendingChanges[i];\n    callWatchers(change.obj, change.prop, change.mode, change.newval, change.oldval);\n  }\n\n  if (change) {\n    pendingChanges = [];\n    change = null;\n  }\n};\n\nvar loop = function () {\n  // check for new or deleted props\n  for (var i = 0; i < lengthsubjects.length; i++) {\n    var subj = lengthsubjects[i];\n\n    if (subj.prop === \"$$watchlengthsubjectroot\") {\n      var difference = getObjDiff(subj.obj, subj.actual);\n\n      if (difference.added.length || difference.removed.length) {\n        if (difference.added.length) {\n          watchMany(subj.obj, difference.added, subj.watcher, subj.level - 1, true);\n        }\n\n        subj.watcher.call(subj.obj, \"root\", \"differentattr\", difference, subj.actual);\n      }\n\n      subj.actual = clone(subj.obj);\n    } else {\n      var difference = getObjDiff(subj.obj[subj.prop], subj.actual);\n\n      if (difference.added.length || difference.removed.length) {\n        if (difference.added.length) {\n          for (var j = 0; j < subj.obj.watchers[subj.prop].length; j++) {\n            watchMany(subj.obj[subj.prop], difference.added, subj.obj.watchers[subj.prop][j], subj.level - 1, true);\n          }\n        }\n\n        callWatchers(subj.obj, subj.prop, \"differentattr\", difference, subj.actual);\n      }\n\n      subj.actual = clone(subj.obj[subj.prop]);\n    }\n  } // start dirty check\n\n\n  var n, value;\n\n  if (dirtyChecklist.length > 0) {\n    for (var i = 0; i < dirtyChecklist.length; i++) {\n      n = dirtyChecklist[i];\n      value = n.object[n.prop];\n\n      if (!compareValues(n.orig, value)) {\n        n.orig = clone(value);\n        n.callback(value);\n      }\n    }\n  }\n};\n\nvar compareValues = function (a, b) {\n  var i,\n      state = true;\n\n  if (a !== b) {\n    if (isObject(a)) {\n      for (i in a) {\n        if (!supportDefineProperty && i === 'watchers') continue;\n\n        if (a[i] !== b[i]) {\n          state = false;\n          break;\n        }\n\n        ;\n      }\n    } else {\n      state = false;\n    }\n  }\n\n  return state;\n};\n\nvar pushToLengthSubjects = function (obj, prop, watcher, level) {\n  var actual;\n\n  if (prop === \"$$watchlengthsubjectroot\") {\n    actual = clone(obj);\n  } else {\n    actual = clone(obj[prop]);\n  }\n\n  lengthsubjects.push({\n    obj: obj,\n    prop: prop,\n    actual: actual,\n    watcher: watcher,\n    level: level\n  });\n};\n\nvar removeFromLengthSubjects = function (obj, prop, watcher) {\n  for (var i = 0; i < lengthsubjects.length; i++) {\n    var subj = lengthsubjects[i];\n\n    if (subj.obj == obj) {\n      if (!prop || subj.prop == prop) {\n        if (!watcher || subj.watcher == watcher) {\n          // if we splice off one item at position i\n          // we need to decrement i as the array is one item shorter\n          // so when we increment i in the loop statement we\n          // will land at the correct index.\n          // if it's not decremented, you won't delete all length subjects\n          lengthsubjects.splice(i--, 1);\n        }\n      }\n    }\n  }\n};\n\nvar removeFromDirtyChecklist = function (obj, prop) {\n  var notInUse;\n\n  for (var i = 0; i < dirtyChecklist.length; i++) {\n    var n = dirtyChecklist[i];\n    var watchers = n.object.watchers;\n    notInUse = n.object == obj && (!prop || n.prop == prop) && watchers && (!prop || !watchers[prop] || watchers[prop].length == 0);\n\n    if (notInUse) {\n      // we use the same syntax as in removeFromLengthSubjects\n      dirtyChecklist.splice(i--, 1);\n    }\n  }\n};\n\nsetInterval(loop, 50);\nWatchJS.watch = watch;\nWatchJS.unwatch = unwatch;\nWatchJS.callWatchers = callWatchers;\nWatchJS.suspend = suspend; // suspend watchers\n\nWatchJS.onChange = trackChange; // track changes made to object or  it's property and return a\n// single change object\n\nexport default WatchJS;","export const holidays = () => {\n  const content = document.querySelectorAll('.modal-content');\n  const country = document.createElement('div');\n  country.classList = 'country-holidays';\n  const countrySelect = document.createElement('select');\n  countrySelect.classList = 'country-select';\n  countrySelect.textContent = 'Choose country : ';\n  const countryName = ['Andorra', 'Albania', 'Argentina', 'Austria', 'Australia', 'Ã…land Islands', 'Bosnia and Herzegovina', 'Barbados', 'Belgium', 'Bulgaria', 'Benin', 'Bolivia', 'Brazil', 'Bahamas', 'Botswana', 'Belarus', 'Belize', 'Canada', 'Switzerland', 'Chile', 'China', 'Colombia', 'Costa Rica', 'Cuba', 'Cyprus', 'Czechia', 'Germany', 'Denmark', 'Dominican Republic', 'Ecuador', 'Estonia', 'Egypt', 'Spain', 'Finland', 'Faroe Islands', 'France', 'Gabon', 'United Kingdom', 'Grenada', 'Guernsey', 'Gibraltar', 'Greenland', 'Gambia', 'Greece', 'Guatemala', 'Guyana', 'Honduras', 'Croatia', 'Haiti', 'Hungary', 'Indonesia', 'Ireland', 'Isle of Man', 'Iceland', 'Italy', 'Jersey', 'Jamaica', 'Japan', 'South Korea', 'Liechtenstein', 'Lesotho', 'Lithuania', 'Luxembourg', 'Latvia', 'Morocco', 'Monaco', 'Moldova', 'Montenegro', 'Madagascar', 'North Macedonia', 'Mongolia', 'Montserrat', 'Malta', 'Mexico', 'Mozambique', 'Namibia', 'Niger', 'Nigeria', 'Nicaragua', 'Netherlands', 'Norway', 'New Zealand', 'Panama', 'Peru', 'Papua New Guinea', 'Poland', 'Puerto Rico', 'Portugal', 'Paraguay', 'Romania', 'Serbia', 'Russia', 'Sweden', 'Singapore', 'Slovenia', 'Svalbard and Jan Mayen', 'Slovakia', 'San Marino', 'Suriname', 'El Salvador', 'Tunisia', 'Turkey', 'Ukraine', 'United States', 'Uruguay', 'Vatican City', 'Venezuela', 'Vietnam', 'South Africa', 'Zimbabwe'];\n  const countryCode = ['AD', 'AL', 'AR', 'AT', 'AU', 'AX', 'BA', 'BB', 'BE', 'BG', 'BJ', 'BO', 'BR', 'BS', 'BW', 'BY', 'BZ', 'CA', 'CH', 'CL', 'CN', 'CO', 'CR', 'CU', 'CY', 'CZ', 'DE', 'DK', 'DO', 'EC', 'EE', 'EG', 'ES', 'FI', 'FO', 'FR', 'GA', 'GB', 'GD', 'GG', 'GI', 'GL', 'GM', 'GR', 'GT', 'GY', 'HN', 'HR', 'HT', 'HU', 'ID', 'IE', 'IM', 'IS', 'IT', 'JE', 'JM', 'JP', 'KR', 'LI', 'LS', 'LT', 'LU', 'LV', 'MA', 'MC', 'MD', 'ME', 'MG', 'MK', 'MN', 'MS', 'MT', 'MX', 'MZ', 'NA', 'NE', 'NG', 'NI', 'NL', 'NO', 'NZ', 'PA', 'PE', 'PG', 'PL', 'PR', 'PT', 'PY', 'RO', 'RS', 'RU', 'SE', 'SG', 'SI', 'SJ', 'SK', 'SM', 'SR', 'SV', 'TN', 'TR', 'UA', 'US', 'UY', 'VA', 'VE', 'VN', 'ZA', 'ZW'];\n  let i = 0;\n  countryCode.forEach(code => {\n    const option = document.createElement('option');\n    option.value = code;\n    option.textContent = countryName[i];\n    countrySelect.append(option);\n    i++;\n  });\n  country.append(countrySelect);\n  content[1].prepend(country);\n  const info = document.createElement('div');\n  info.classList = 'info-holidays';\n  countrySelect.addEventListener('change', () => {\n    const table = document.createElement('table');\n    table.classList = 'table';\n    let index = countrySelect.selectedIndex;\n    let countrySelected = countrySelect[index].value;\n    fetch('https://date.nager.at/api/v3/publicholidays/2017/' + countrySelected).then(response => response.json()).then(data => {\n      data.forEach(d => {\n        const cell = document.createElement('th');\n        cell.classList = 'cell';\n        const line = document.createElement('tr');\n        line.classList = 'line';\n        cell.append(\"Date: \" + d.date + \". Local name :  \" + d.localName + \". Name : \" + d.name);\n        line.append(cell);\n        table.append(line);\n        info.append(table);\n        country.append(info);\n      });\n    }).catch(err => console.error(err));\n    const th = document.querySelectorAll('.cell');\n    th.forEach(t => {\n      t.remove();\n    });\n  });\n};","import { MODALS_TYPES } from \"./const.js\";\nexport default {\n  openedModalType: MODALS_TYPES.NONE\n};\nexport const factState = {\n  facts: []\n};","import WatchJS from './helpers/melanke-watchjs.js';\nimport state from './state.js';\nimport { MODALS_TYPES } from \"./const.js\";\nconst watch = WatchJS.watch;\nwatch(state, 'openedModalType', () => {\n  const allModals = document.querySelectorAll('.modal');\n  allModals.forEach(item => {\n    item.style.display = 'none';\n  });\n\n  if (state.openedModalType !== MODALS_TYPES.NONE) {\n    const modal = document.querySelector(`.modal[data-type=\"${state.openedModalType}\"]`);\n    modal.style.display = 'block';\n  }\n});","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import { BUTTONS, MODALS, MODALS_TYPES } from \"./const.js\";\nimport state from './state.js';\nimport './watchers.js';\nimport { catfacts } from \"./catfacts.js\";\nimport { holidays } from \"./holidays.js\";\nimport { currency } from \"./currency.js\";\n\nconst closeModal = () => {\n  state.openedModalType = MODALS_TYPES.NONE;\n};\n\nconst renderButtons = () => {\n  const buttonsContainer = document.querySelector('.buttons');\n  BUTTONS.forEach(item => {\n    const button = document.createElement('button');\n    button.textContent = item.text;\n    button.dataset.type = item.type;\n    button.classList = 'btn';\n    button.addEventListener('click', event => {\n      state.openedModalType = item.type;\n      event.stopPropagation();\n    });\n    buttonsContainer.append(button);\n  });\n};\n\nconst renderModals = () => {\n  const app = document.querySelector('.app');\n  MODALS.forEach(item => {\n    const modal = document.createElement('div');\n    const prevButton = document.createElement('button');\n    const nextButton = document.createElement('button');\n    const closeButton = document.createElement('button');\n    const content = document.createElement('div');\n    content.classList = 'modal-content';\n    prevButton.textContent = 'Prev';\n    prevButton.classList = 'prev';\n    prevButton.addEventListener('click', event => {\n      const currentOpenedModalIndex = MODALS.findIndex(item => item.type === state.openedModalType);\n\n      if (currentOpenedModalIndex === 0) {\n        state.openedModalType = MODALS[MODALS.length - 1].type;\n      } else {\n        state.openedModalType = MODALS[currentOpenedModalIndex - 1].type;\n      }\n\n      event.stopPropagation();\n    });\n    nextButton.textContent = 'Next';\n    nextButton.classList = 'next';\n    nextButton.addEventListener('click', event => {\n      const currentOpenedModalIndex = MODALS.findIndex(item => item.type === state.openedModalType);\n\n      if (currentOpenedModalIndex === MODALS.length - 1) {\n        state.openedModalType = MODALS[0].type;\n      } else {\n        state.openedModalType = MODALS[currentOpenedModalIndex + 1].type;\n      }\n\n      event.stopPropagation();\n    });\n    closeButton.textContent = 'Close';\n    closeButton.classList = 'close';\n    closeButton.addEventListener('click', event => {\n      closeModal();\n      event.stopPropagation();\n    });\n    modal.dataset.type = item.type;\n    modal.classList.add('modal');\n    const header = document.createElement('div');\n    header.classList = 'header';\n    header.textContent = item.text;\n    modal.append(header);\n    modal.append(prevButton);\n    modal.append(nextButton);\n    modal.append(closeButton);\n    modal.append(content);\n    app.append(modal);\n  });\n};\n\nrenderModals();\nrenderButtons();\ncatfacts();\nholidays();\ncurrency();"],"names":[],"sourceRoot":""}