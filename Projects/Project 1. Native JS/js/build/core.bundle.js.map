{"version":3,"file":"core.bundle.js","mappings":";;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACjyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","sources":["webpack://Project 1. Native JS/./helpers/melanke-watchjs.js","webpack://Project 1. Native JS/./js/watcher.js","webpack://Project 1. Native JS/webpack/bootstrap","webpack://Project 1. Native JS/webpack/runtime/define property getters","webpack://Project 1. Native JS/webpack/runtime/hasOwnProperty shorthand","webpack://Project 1. Native JS/webpack/runtime/make namespace object","webpack://Project 1. Native JS/./js/index.js"],"sourcesContent":["var WatchJS = {\n  noMore: false,\n  // use WatchJS.suspend(obj) instead\n  useDirtyCheck: false,\n  // use only dirty checking to track changes.\n  preserveExistingSetters: false\n},\n    lengthsubjects = [];\nvar dirtyChecklist = [];\nvar pendingChanges = []; // used coalesce changes from defineProperty and __defineSetter__\n\nvar supportDefineProperty = false;\n\ntry {\n  supportDefineProperty = Object.defineProperty && Object.defineProperty({}, 'x', {});\n} catch (ex) {\n  /* not supported */\n}\n\nvar isFunction = function (functionToCheck) {\n  var getType = {};\n  return functionToCheck && getType.toString.call(functionToCheck) == '[object Function]';\n};\n\nvar isInt = function (x) {\n  return x % 1 === 0;\n};\n\nvar isArray = function (obj) {\n  return Object.prototype.toString.call(obj) === '[object Array]';\n};\n\nvar isObject = function (obj) {\n  return {}.toString.apply(obj) === '[object Object]';\n};\n\nvar getObjDiff = function (a, b) {\n  var aplus = [],\n      bplus = [];\n\n  if (!(typeof a == \"string\") && !(typeof b == \"string\")) {\n    if (isArray(a) && b) {\n      for (var i = 0; i < a.length; i++) {\n        if (b[i] === undefined) aplus.push(i);\n      }\n    } else {\n      for (var i in a) {\n        if (a.hasOwnProperty(i)) {\n          if (b && !b.hasOwnProperty(i)) {\n            aplus.push(i);\n          }\n        }\n      }\n    }\n\n    if (isArray(b) && a) {\n      for (var j = 0; j < b.length; j++) {\n        if (a[j] === undefined) bplus.push(j);\n      }\n    } else {\n      for (var j in b) {\n        if (b.hasOwnProperty(j)) {\n          if (a && !a.hasOwnProperty(j)) {\n            bplus.push(j);\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    added: aplus,\n    removed: bplus\n  };\n};\n\nvar clone = function (obj) {\n  if (null == obj || \"object\" != typeof obj) {\n    return obj;\n  }\n\n  var copy = obj.constructor();\n\n  for (var attr in obj) {\n    copy[attr] = obj[attr];\n  }\n\n  return copy;\n};\n\nvar getExistingSetter = function (obj, propName) {\n  if (WatchJS.preserveExistingSetters) {\n    var existing = Object.getOwnPropertyDescriptor(obj, propName);\n    return existing.set;\n  }\n\n  return undefined;\n};\n\nvar defineGetAndSet = function (obj, propName, getter, setter) {\n  try {\n    var existingSetter = getExistingSetter(obj, propName);\n    Object.defineProperty(obj, propName, {\n      get: getter,\n      set: function (value) {\n        setter.call(this, value, true); // coalesce changes\n\n        if (existingSetter) {\n          existingSetter(value);\n        }\n      },\n      enumerable: true,\n      configurable: true\n    });\n  } catch (e1) {\n    try {\n      Object.prototype.__defineGetter__.call(obj, propName, getter);\n\n      Object.prototype.__defineSetter__.call(obj, propName, function (value) {\n        setter.call(this, value, true); // coalesce changes\n      });\n    } catch (e2) {\n      observeDirtyChanges(obj, propName, setter); //throw new Error(\"watchJS error: browser not supported :/\")\n    }\n  }\n};\n\nvar defineProp = function (obj, propName, value) {\n  try {\n    Object.defineProperty(obj, propName, {\n      enumerable: false,\n      configurable: true,\n      writable: false,\n      value: value\n    });\n  } catch (error) {\n    obj[propName] = value;\n  }\n};\n\nvar observeDirtyChanges = function (obj, propName, setter) {\n  dirtyChecklist[dirtyChecklist.length] = {\n    prop: propName,\n    object: obj,\n    orig: clone(obj[propName]),\n    callback: setter\n  };\n};\n\nvar watch = function () {\n  if (isFunction(arguments[1])) {\n    watchAll.apply(this, arguments);\n  } else if (isArray(arguments[1])) {\n    watchMany.apply(this, arguments);\n  } else {\n    watchOne.apply(this, arguments);\n  }\n};\n\nvar watchAll = function (obj, watcher, level, addNRemove) {\n  if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n    //accepts only objects and array (not string)\n    return;\n  }\n\n  if (isArray(obj)) {\n    defineWatcher(obj, \"__watchall__\", watcher, level); // watch all changes on the array\n\n    if (level === undefined || level > 0) {\n      for (var prop = 0; prop < obj.length; prop++) {\n        // watch objects in array\n        watchAll(obj[prop], watcher, level, addNRemove);\n      }\n    }\n  } else {\n    var prop,\n        props = [];\n\n    for (prop in obj) {\n      //for each attribute if obj is an object\n      if (prop == \"$val\" || !supportDefineProperty && prop === 'watchers') {\n        continue;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(obj, prop)) {\n        props.push(prop); //put in the props\n      }\n    }\n\n    watchMany(obj, props, watcher, level, addNRemove); //watch all items of the props\n  }\n\n  if (addNRemove) {\n    pushToLengthSubjects(obj, \"$$watchlengthsubjectroot\", watcher, level);\n  }\n};\n\nvar watchMany = function (obj, props, watcher, level, addNRemove) {\n  if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n    //accepts only objects and array (not string)\n    return;\n  }\n\n  for (var i = 0; i < props.length; i++) {\n    //watch each property\n    var prop = props[i];\n    watchOne(obj, prop, watcher, level, addNRemove);\n  }\n};\n\nvar watchOne = function (obj, prop, watcher, level, addNRemove) {\n  if (typeof obj == \"string\" || !(obj instanceof Object) && !isArray(obj)) {\n    //accepts only objects and array (not string)\n    return;\n  }\n\n  if (isFunction(obj[prop])) {\n    //dont watch if it is a function\n    return;\n  }\n\n  if (obj[prop] != null && (level === undefined || level > 0)) {\n    watchAll(obj[prop], watcher, level !== undefined ? level - 1 : level); //recursively\n    // watch all\n    // attributes of\n    // this\n  }\n\n  defineWatcher(obj, prop, watcher, level);\n\n  if (addNRemove && (level === undefined || level > 0)) {\n    pushToLengthSubjects(obj, prop, watcher, level);\n  }\n};\n\nvar unwatch = function () {\n  if (isFunction(arguments[1])) {\n    unwatchAll.apply(this, arguments);\n  } else if (isArray(arguments[1])) {\n    unwatchMany.apply(this, arguments);\n  } else {\n    unwatchOne.apply(this, arguments);\n  }\n};\n\nvar unwatchAll = function (obj, watcher) {\n  if (obj instanceof String || !(obj instanceof Object) && !isArray(obj)) {\n    //accepts only objects and array (not string)\n    return;\n  }\n\n  if (isArray(obj)) {\n    var props = ['__watchall__'];\n\n    for (var prop = 0; prop < obj.length; prop++) {\n      //for each item if obj is an array\n      props.push(prop); //put in the props\n    }\n\n    unwatchMany(obj, props, watcher); //watch all itens of the props\n  } else {\n    var unwatchPropsInObject = function (obj2) {\n      var props = [];\n\n      for (var prop2 in obj2) {\n        //for each attribute if obj is an object\n        if (obj2.hasOwnProperty(prop2)) {\n          if (obj2[prop2] instanceof Object) {\n            unwatchPropsInObject(obj2[prop2]); //recurs into object props\n          } else {\n            props.push(prop2); //put in the props\n          }\n        }\n      }\n\n      unwatchMany(obj2, props, watcher); //unwatch all of the props\n    };\n\n    unwatchPropsInObject(obj);\n  }\n};\n\nvar unwatchMany = function (obj, props, watcher) {\n  for (var prop2 in props) {\n    //watch each attribute of \"props\" if is an object\n    if (props.hasOwnProperty(prop2)) {\n      unwatchOne(obj, props[prop2], watcher);\n    }\n  }\n};\n\nvar timeouts = [],\n    timerID = null;\n\nfunction clearTimerID() {\n  timerID = null;\n\n  for (var i = 0; i < timeouts.length; i++) {\n    timeouts[i]();\n  }\n\n  timeouts.length = 0;\n}\n\nvar getTimerID = function () {\n  if (!timerID) {\n    timerID = setTimeout(clearTimerID);\n  }\n\n  return timerID;\n};\n\nvar registerTimeout = function (fn) {\n  // register function to be called on timeout\n  if (timerID == null) getTimerID();\n  timeouts[timeouts.length] = fn;\n}; // Track changes made to an array, object or an object's property\n// and invoke callback with a single change object containing type, value, oldvalue and array\n// splices Syntax:  trackChange(obj, callback, recursive, addNRemove) trackChange(obj, prop,\n// callback, recursive, addNRemove)\n\n\nvar trackChange = function () {\n  var fn = isFunction(arguments[2]) ? trackProperty : trackObject;\n  fn.apply(this, arguments);\n}; // track changes made to an object and invoke callback with a single change object containing\n// type, value and array splices\n\n\nvar trackObject = function (obj, callback, recursive, addNRemove) {\n  var change = null,\n      lastTimerID = -1;\n  var isArr = isArray(obj);\n\n  var level,\n      fn = function (prop, action, newValue, oldValue) {\n    var timerID = getTimerID();\n\n    if (lastTimerID !== timerID) {\n      // check if timer has changed since last update\n      lastTimerID = timerID;\n      change = {\n        type: 'update'\n      };\n      change['value'] = obj;\n      change['splices'] = null;\n      registerTimeout(function () {\n        callback.call(this, change);\n        change = null;\n      });\n    } // create splices for array changes\n\n\n    if (isArr && obj === this && change !== null) {\n      if (action === 'pop' || action === 'shift') {\n        newValue = [];\n        oldValue = [oldValue];\n      } else if (action === 'push' || action === 'unshift') {\n        newValue = [newValue];\n        oldValue = [];\n      } else if (action !== 'splice') {\n        return; // return here - for reverse and sort operations we don't need to\n        // return splices. a simple update will do\n      }\n\n      if (!change.splices) change.splices = [];\n      change.splices[change.splices.length] = {\n        index: prop,\n        deleteCount: oldValue ? oldValue.length : 0,\n        addedCount: newValue ? newValue.length : 0,\n        added: newValue,\n        deleted: oldValue\n      };\n    }\n  };\n\n  level = recursive == true ? undefined : 0;\n  watchAll(obj, fn, level, addNRemove);\n}; // track changes made to the property of an object and invoke callback with a single change\n// object containing type, value, oldvalue and splices\n\n\nvar trackProperty = function (obj, prop, callback, recursive, addNRemove) {\n  if (obj && prop) {\n    watchOne(obj, prop, function (prop, action, newvalue, oldvalue) {\n      var change = {\n        type: 'update'\n      };\n      change['value'] = newvalue;\n      change['oldvalue'] = oldvalue;\n\n      if (recursive && isObject(newvalue) || isArray(newvalue)) {\n        trackObject(newvalue, callback, recursive, addNRemove);\n      }\n\n      callback.call(this, change);\n    }, 0);\n\n    if (recursive && isObject(obj[prop]) || isArray(obj[prop])) {\n      trackObject(obj[prop], callback, recursive, addNRemove);\n    }\n  }\n};\n\nvar defineWatcher = function (obj, prop, watcher, level) {\n  var newWatcher = false;\n  var isArr = isArray(obj);\n\n  if (!obj.watchers) {\n    defineProp(obj, \"watchers\", {});\n\n    if (isArr) {\n      // watch array functions\n      watchFunctions(obj, function (index, action, newValue, oldValue) {\n        addPendingChange(obj, index, action, newValue, oldValue);\n\n        if (level !== 0 && newValue && (isObject(newValue) || isArray(newValue))) {\n          var i,\n              n,\n              ln,\n              wAll,\n              watchList = obj.watchers[prop];\n\n          if (wAll = obj.watchers['__watchall__']) {\n            watchList = watchList ? watchList.concat(wAll) : wAll;\n          }\n\n          ln = watchList ? watchList.length : 0;\n\n          for (i = 0; i < ln; i++) {\n            if (action !== 'splice') {\n              watchAll(newValue, watchList[i], level === undefined ? level : level - 1);\n            } else {\n              // watch spliced values\n              for (n = 0; n < newValue.length; n++) {\n                watchAll(newValue[n], watchList[i], level === undefined ? level : level - 1);\n              }\n            }\n          }\n        }\n      });\n    }\n  }\n\n  if (!obj.watchers[prop]) {\n    obj.watchers[prop] = [];\n    if (!isArr) newWatcher = true;\n  }\n\n  for (var i = 0; i < obj.watchers[prop].length; i++) {\n    if (obj.watchers[prop][i] === watcher) {\n      return;\n    }\n  }\n\n  obj.watchers[prop].push(watcher); //add the new watcher to the watchers array\n\n  if (newWatcher) {\n    var val = obj[prop];\n\n    var getter = function () {\n      return val;\n    };\n\n    var setter = function (newval, delayWatcher) {\n      var oldval = val;\n      val = newval;\n\n      if (level !== 0 && obj[prop] && (isObject(obj[prop]) || isArray(obj[prop])) && !obj[prop].watchers) {\n        // watch sub properties\n        var i,\n            ln = obj.watchers[prop].length;\n\n        for (i = 0; i < ln; i++) {\n          watchAll(obj[prop], obj.watchers[prop][i], level === undefined ? level : level - 1);\n        }\n      } //watchFunctions(obj, prop);\n\n\n      if (isSuspended(obj, prop)) {\n        resume(obj, prop);\n        return;\n      }\n\n      if (!WatchJS.noMore) {\n        // this does not work with Object.observe\n        //if (JSON.stringify(oldval) !== JSON.stringify(newval)) {\n        if (obj[prop] instanceof Date && oldval && newval) {\n          oldval = oldval.valueOf();\n          newval = newval.valueOf();\n        }\n\n        if (oldval !== newval) {\n          if (!delayWatcher) {\n            callWatchers(obj, prop, \"set\", newval, oldval);\n          } else {\n            addPendingChange(obj, prop, \"set\", newval, oldval);\n          }\n\n          WatchJS.noMore = false;\n        }\n      }\n    };\n\n    if (WatchJS.useDirtyCheck) {\n      observeDirtyChanges(obj, prop, setter);\n    } else {\n      defineGetAndSet(obj, prop, getter, setter);\n    }\n  }\n};\n\nvar callWatchers = function (obj, prop, action, newval, oldval) {\n  if (prop !== undefined) {\n    var ln,\n        wl,\n        watchList = obj.watchers[prop];\n\n    if (wl = obj.watchers['__watchall__']) {\n      watchList = watchList ? watchList.concat(wl) : wl;\n    }\n\n    ln = watchList ? watchList.length : 0;\n\n    for (var wr = 0; wr < ln; wr++) {\n      watchList[wr].call(obj, prop, action, newval, oldval);\n    }\n  } else {\n    for (var prop in obj) {\n      //call all\n      if (obj.hasOwnProperty(prop)) {\n        callWatchers(obj, prop, action, newval, oldval);\n      }\n    }\n  }\n};\n\nvar methodNames = ['pop', 'push', 'reverse', 'shift', 'sort', 'slice', 'unshift', 'splice'];\n\nvar defineArrayMethodWatcher = function (obj, original, methodName, callback) {\n  defineProp(obj, methodName, function () {\n    var index = 0;\n    var i, newValue, oldValue, response; // get values before splicing array\n\n    if (methodName === 'splice') {\n      var start = arguments[0];\n      var end = start + arguments[1];\n      oldValue = obj.slice(start, end);\n      newValue = [];\n\n      for (i = 2; i < arguments.length; i++) {\n        newValue[i - 2] = arguments[i];\n      }\n\n      index = start;\n    } else {\n      newValue = arguments.length > 0 ? arguments[0] : undefined;\n    }\n\n    response = original.apply(obj, arguments);\n\n    if (methodName !== 'slice') {\n      if (methodName === 'pop') {\n        oldValue = response;\n        index = obj.length;\n      } else if (methodName === 'push') {\n        index = obj.length - 1;\n      } else if (methodName === 'shift') {\n        oldValue = response;\n      } else if (methodName !== 'unshift' && newValue === undefined) {\n        newValue = response;\n      }\n\n      callback.call(obj, index, methodName, newValue, oldValue);\n    }\n\n    return response;\n  });\n};\n\nvar watchFunctions = function (obj, callback) {\n  if (!isFunction(callback) || !obj || obj instanceof String || !isArray(obj)) {\n    return;\n  }\n\n  for (var i = methodNames.length, methodName; i--;) {\n    methodName = methodNames[i];\n    defineArrayMethodWatcher(obj, obj[methodName], methodName, callback);\n  }\n};\n\nvar unwatchOne = function (obj, prop, watcher) {\n  if (prop) {\n    if (obj.watchers && obj.watchers[prop]) {\n      if (watcher === undefined) {\n        delete obj.watchers[prop]; // remove all property watchers\n      } else {\n        for (var i = 0; i < obj.watchers[prop].length; i++) {\n          var w = obj.watchers[prop][i];\n\n          if (w == watcher) {\n            obj.watchers[prop].splice(i, 1);\n          }\n        }\n      }\n    }\n  } else {\n    delete obj.watchers;\n  }\n\n  removeFromLengthSubjects(obj, prop, watcher);\n  removeFromDirtyChecklist(obj, prop);\n}; // suspend watchers until next update cycle\n\n\nvar suspend = function (obj, prop) {\n  if (obj.watchers) {\n    var name = '__wjs_suspend__' + (prop !== undefined ? prop : '');\n    obj.watchers[name] = true;\n  }\n};\n\nvar isSuspended = function (obj, prop) {\n  return obj.watchers && (obj.watchers['__wjs_suspend__'] || obj.watchers['__wjs_suspend__' + prop]);\n}; // resumes preivously suspended watchers\n\n\nvar resume = function (obj, prop) {\n  registerTimeout(function () {\n    delete obj.watchers['__wjs_suspend__'];\n    delete obj.watchers['__wjs_suspend__' + prop];\n  });\n};\n\nvar pendingTimerID = null;\n\nvar addPendingChange = function (obj, prop, mode, newval, oldval) {\n  pendingChanges[pendingChanges.length] = {\n    obj: obj,\n    prop: prop,\n    mode: mode,\n    newval: newval,\n    oldval: oldval\n  };\n\n  if (pendingTimerID === null) {\n    pendingTimerID = setTimeout(applyPendingChanges);\n  }\n};\n\nvar applyPendingChanges = function () {\n  // apply pending changes\n  var change = null;\n  pendingTimerID = null;\n\n  for (var i = 0; i < pendingChanges.length; i++) {\n    change = pendingChanges[i];\n    callWatchers(change.obj, change.prop, change.mode, change.newval, change.oldval);\n  }\n\n  if (change) {\n    pendingChanges = [];\n    change = null;\n  }\n};\n\nvar loop = function () {\n  // check for new or deleted props\n  for (var i = 0; i < lengthsubjects.length; i++) {\n    var subj = lengthsubjects[i];\n\n    if (subj.prop === \"$$watchlengthsubjectroot\") {\n      var difference = getObjDiff(subj.obj, subj.actual);\n\n      if (difference.added.length || difference.removed.length) {\n        if (difference.added.length) {\n          watchMany(subj.obj, difference.added, subj.watcher, subj.level - 1, true);\n        }\n\n        subj.watcher.call(subj.obj, \"root\", \"differentattr\", difference, subj.actual);\n      }\n\n      subj.actual = clone(subj.obj);\n    } else {\n      var difference = getObjDiff(subj.obj[subj.prop], subj.actual);\n\n      if (difference.added.length || difference.removed.length) {\n        if (difference.added.length) {\n          for (var j = 0; j < subj.obj.watchers[subj.prop].length; j++) {\n            watchMany(subj.obj[subj.prop], difference.added, subj.obj.watchers[subj.prop][j], subj.level - 1, true);\n          }\n        }\n\n        callWatchers(subj.obj, subj.prop, \"differentattr\", difference, subj.actual);\n      }\n\n      subj.actual = clone(subj.obj[subj.prop]);\n    }\n  } // start dirty check\n\n\n  var n, value;\n\n  if (dirtyChecklist.length > 0) {\n    for (var i = 0; i < dirtyChecklist.length; i++) {\n      n = dirtyChecklist[i];\n      value = n.object[n.prop];\n\n      if (!compareValues(n.orig, value)) {\n        n.orig = clone(value);\n        n.callback(value);\n      }\n    }\n  }\n};\n\nvar compareValues = function (a, b) {\n  var i,\n      state = true;\n\n  if (a !== b) {\n    if (isObject(a)) {\n      for (i in a) {\n        if (!supportDefineProperty && i === 'watchers') continue;\n\n        if (a[i] !== b[i]) {\n          state = false;\n          break;\n        }\n\n        ;\n      }\n    } else {\n      state = false;\n    }\n  }\n\n  return state;\n};\n\nvar pushToLengthSubjects = function (obj, prop, watcher, level) {\n  var actual;\n\n  if (prop === \"$$watchlengthsubjectroot\") {\n    actual = clone(obj);\n  } else {\n    actual = clone(obj[prop]);\n  }\n\n  lengthsubjects.push({\n    obj: obj,\n    prop: prop,\n    actual: actual,\n    watcher: watcher,\n    level: level\n  });\n};\n\nvar removeFromLengthSubjects = function (obj, prop, watcher) {\n  for (var i = 0; i < lengthsubjects.length; i++) {\n    var subj = lengthsubjects[i];\n\n    if (subj.obj == obj) {\n      if (!prop || subj.prop == prop) {\n        if (!watcher || subj.watcher == watcher) {\n          // if we splice off one item at position i\n          // we need to decrement i as the array is one item shorter\n          // so when we increment i in the loop statement we\n          // will land at the correct index.\n          // if it's not decremented, you won't delete all length subjects\n          lengthsubjects.splice(i--, 1);\n        }\n      }\n    }\n  }\n};\n\nvar removeFromDirtyChecklist = function (obj, prop) {\n  var notInUse;\n\n  for (var i = 0; i < dirtyChecklist.length; i++) {\n    var n = dirtyChecklist[i];\n    var watchers = n.object.watchers;\n    notInUse = n.object == obj && (!prop || n.prop == prop) && watchers && (!prop || !watchers[prop] || watchers[prop].length == 0);\n\n    if (notInUse) {\n      // we use the same syntax as in removeFromLengthSubjects\n      dirtyChecklist.splice(i--, 1);\n    }\n  }\n};\n\nsetInterval(loop, 50);\nWatchJS.watch = watch;\nWatchJS.unwatch = unwatch;\nWatchJS.callWatchers = callWatchers;\nWatchJS.suspend = suspend; // suspend watchers\n\nWatchJS.onChange = trackChange; // track changes made to object or  it's property and return a\n// single change object\n\nexport default WatchJS;","import WatchJS from \"../helpers/melanke-watchjs\";\nconst {\n  watch\n} = WatchJS;\n\nconst watchState = modalWindows => {\n  watch(modalWindows, 'currentIndex', () => {\n    modalWindows.list[modalWindows.currentIndex].style.display = 'flex';\n    modalWindows.list[modalWindows.prevIndex].style.display = 'none';\n  });\n};\n\nexport default watchState;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import watchState from './watcher.js';\nconst buttons = document.querySelector('.buttons');\nconst modalWindows = {\n  //состояние\n  currentIndex: 0,\n  action: '',\n  prevIndex: 0,\n  list: [buttons, ...document.querySelectorAll('.modal')]\n};\n\nconst currentToPrevIndex = () => {\n  //чтобы не повторяться, присваивание текущего предыдущему индексу\n  modalWindows.prevIndex = modalWindows.currentIndex;\n};\n\nbuttons.addEventListener('click', event => {\n  //кнопки в главном модуле\n  modalWindows.prevIndex = 0;\n  modalWindows.currentIndex = [...buttons.children].indexOf(event.target) + 1;\n});\nconst prevButtons = document.querySelectorAll('.button-prev'); //все кнопки возврата\n\nprevButtons.forEach(element => element.addEventListener('click', event => {\n  currentToPrevIndex();\n  modalWindows.currentIndex = (modalWindows.prevIndex - 4) % 3 + 3;\n}));\nconst nextButtons = document.querySelectorAll('.button-next'); //все кнопки следующего\n\nnextButtons.forEach(element => element.addEventListener('click', event => {\n  currentToPrevIndex();\n  modalWindows.currentIndex = modalWindows.prevIndex % 3 + 1;\n}));\nconst closeButtons = document.querySelectorAll('.button-close');\ncloseButtons.forEach(element => element.addEventListener('click', event => {\n  currentToPrevIndex();\n  modalWindows.currentIndex = 0;\n}));\nwatchState(modalWindows);"],"names":[],"sourceRoot":""}